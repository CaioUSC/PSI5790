# -*- coding: utf-8 -*-
"""Exercicio1_Aula5PSI5790.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o04d_UUoYCVaaKWjrxFqS0bTfirxvw0G
"""

import numpy as np
from sklearn.metrics import roc_curve, roc_auc_score
import matplotlib.pyplot as plt

qp = [0.32073036, 0.27087152, 0.37556642, 0.2301418 , 0.40878805]
qy = [0,0,0,0,1]

# Curva ROC
fpr, tpr, thresholds = roc_curve(qy, qp)

# AUC
auc = roc_auc_score(qy, qp)

# EER (Equal Error Rate)
fnr = 1 - tpr
eer_threshold = thresholds[np.nanargmin(np.absolute(fnr - fpr))]
eer = fpr[np.nanargmin(np.absolute(fnr - fpr))]

# Plot
plt.figure()
plt.plot(fpr, tpr, marker='o', label='ROC Curve')
plt.plot([0, 1], [0, 1], 'k--', label='Random')
plt.scatter(eer, 1-eer, color='red', label=f'EER = {eer:.2f}')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title(f'ROC Curve (AUC = {auc:.2f})')
plt.legend()
plt.grid()
plt.show()

# Resultados
print(f"AUC: {auc:.4f}")
print(f"EER: {eer:.4f} (Threshold: {eer_threshold:.4f})")

"""
### Conceitos:
**Verdadeiro positivo(TP):** Uma nota falsa é corretamente classificada como falsa
<br>
**Falso Negativo(FN):** Uma nota falsa é classificada erroaneamente como verdadeira
<br>
**Verdadeiro Negativo(TN):** Uma nota verdadeira é corretamente classificada como verdadeira
<br>
**Falso Positivo(FP):** Uma nota verdadeira é classificada erroanemente como falsa


**Sensibilidade:** É a porcentagem de notas falsas que são detectadas corretamente como falsas

\begin{equation}
  \frac{TP}{TP+FN}
\end{equation}

**Especificidade:** É a porcetagem de notas verdadeiras que são classificadas corretamente como verdadeiras

\begin{equation}
  \frac{TN}{TN+FP}
 \end{equation}

**Taxa de acerto ou acuracidade:** É a quantidade de elementos classificados corretamente dividido pelo total de elementos

\begin{equation}
 \frac{TP + TN}{TP+TN+FN+FP}
\end{equation}

**Taxa de erro:** (1 - acuracidade)"""

# Inicialização das variaveis
TP = 0
TN = 0
FP = 0
FN = 0

# Classificação com limiar de 0.3
Threshold = 0.3
qx = []
for i in range(len(qp)):
    if qp[i] > Threshold:
        qx.append(1)
    else:
        qx.append(0)
qx

# Calcula a Sensibilidade e especificidade de qp e qy com um limiar de 0.3

for i in range(len(qx)):
    if qx[i] == qy[i]:
        if qx[i] == 1:
            TP += 1
        else:
            TN += 1
    else:
        if qx[i] == 1:
            FP += 1
        else:
            FN += 1

# Sensibilidade
sensibilidade_3 = TP/(TP+FN)
# Especificidade
especificidade_3 = TN/(TN+FP)
# Taxa de acerto
acuracidade_3 = (TP+TN)/(TP+TN+FP+FN)
# Taxa de erro
erro_3 = 1 - acuracidade_3

print(f"Sensibilidade: {sensibilidade_3}")
print(f"Especificidade: {especificidade_3}")
print(f"Acuracidade: {acuracidade_3}")
print(f"Erro: {erro_3}")

# Inicialização das variaveis
TP = 0
TN = 0
FP = 0
FN = 0

# Classificação com limiar de 0.4
Threshold = 0.4
qx = []
for i in range(len(qp)):
    if qp[i] > Threshold:
        qx.append(1)
    else:
        qx.append(0)
qx

# Calcula a Sensibilidade e especificidade de qp e qy com um limiar de 0.4

for i in range(len(qx)):
    if qx[i] == qy[i]:
        if qx[i] == 1:
            TP += 1
        else:
            TN += 1
    else:
        if qx[i] == 1:
            FP += 1
        else:
            FN += 1

# Sensibilidade
sensibilidade_4 = TP/(TP+FN)
# Especificidade
especificidade_4 = TN/(TN+FP)
# Taxa de acerto
acuracidade_4 = (TP+TN)/(TP+TN+FP+FN)
# Taxa de erro
erro_4 = 1 - acuracidade_4

print(f"Sensibilidade: {sensibilidade_4}")
print(f"Especificidade: {especificidade_4}")
print(f"Acuracidade: {acuracidade_4}")
print(f"Erro: {erro_4}")

# Inicialização das variaveis
TP = 0
TN = 0
FP = 0
FN = 0

# Classificação com limiar de 0.5
Threshold = 0.5
qx = []
for i in range(len(qp)):
    if qp[i] > Threshold:
        qx.append(1)
    else:
        qx.append(0)
qx

# Calcula a Sensibilidade e especificidade de qp e qy com um limiar de 0.5

for i in range(len(qx)):
    if qx[i] == qy[i]:
        if qx[i] == 1:
            TP += 1
        else:
            TN += 1
    else:
        if qx[i] == 1:
            FP += 1
        else:
            FN += 1

# Sensibilidade
sensibilidade_5 = TP/(TP+FN)
# Especificidade
especificidade_5 = TN/(TN+FP)
# Taxa de acerto
acuracidade_5 = (TP+TN)/(TP+TN+FP+FN)
# Taxa de erro
erro_5 = 1 - acuracidade_5

print(f"Sensibilidade: {sensibilidade_5}")
print(f"Especificidade: {especificidade_5}")
print(f"Acuracidade: {acuracidade_5}")
print(f"Erro: {erro_5}")

print("Limiar 0.3:")
print(f"Sensibilidade: {sensibilidade_3}")
print(f"Especificidade: {especificidade_3}")
print(f"Acuracidade: {acuracidade_3}")
print(f"Erro: {erro_3}")
print("Limiar 0.4:")
print(f"Sensibilidade: {sensibilidade_4}")
print(f"Especificidade: {especificidade_4}")
print(f"Acuracidade: {acuracidade_4}")
print(f"Erro: {erro_4}")
print("Limiar 0.5:")
print(f"Sensibilidade: {sensibilidade_5}")
print(f"Especificidade: {especificidade_5}")
print(f"Acuracidade: {acuracidade_5}")
print(f"Erro: {erro_5}")