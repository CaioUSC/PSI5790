# -*- coding: utf-8 -*-
"""Banknote.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JJJoCblNY44NVsmLGlKE7qYSjHSwtj51

# Programa para identificação de notas falsas
## Base de dados disponivel em:
## https://archive.ics.uci.edu/dataset/267/banknote+authentication
"""

# Bibliotecas importadas
import numpy as np
from sklearn import neighbors
from sklearn import tree
from sklearn import svm
import matplotlib.pyplot as plt

"""### Os arquivo original foi transformado nos arquivos ax,ay,qx e qy"""

# define a função para ler arquivos e transformar em matrizes
def le(nomearq):
  with open(nomearq,"r") as f:
    linhas = f.readlines()
  # primeira linha dos arquivos tem o numero de linhas e o numero de colunas
  linha0 = linhas[0].split()
  numeroLinhas=int(linha0[0])
  numeroColunas=int(linha0[1])
  a=np.empty((numeroLinhas,numeroColunas),dtype=np.float32)
  for l in range(numeroLinhas):
    linha=linhas[l+1].split()
    for c in range(numeroColunas):
      a[l,c] = np.float32(linha[c])
  return a

## Le os arquivos com a base de treino e teste
ax = le("ax.txt") # Base de treino das features
ay = le("ay.txt") # Base de treino das labels
qx = le("qx.txt") # Base de teste das features
qy = le("qy.txt") # Base de teste das labels

"""### Classificador KNN"""

# classificador KNN
vizinho = neighbors.KNeighborsClassifier(n_neighbors=1,weights="uniform", algorithm="brute")
# Treina o classificador com a base de teste
vizinho.fit(ax,ay.ravel())
# Realiza a predição na base de teste
qp = vizinho.predict(qx)
erros=0
for i in range(qp.shape[0]):
  if qp[i]!=qy[i]: erros+=1
print("Erros=%d/%d.   Pct=%1.3f%%\n"%(erros,qp.shape[0],100.0*erros/qp.shape[0]))

"""### Arvore de decisão"""

# classificador arvore de decisão
arvore = tree.DecisionTreeClassifier()
# Treina o classificador com a base de teste
arvore = arvore.fit(ax,ay)
# Realiza a predição na base de teste
qp=arvore.predict(qx)
erros=0;
for i in range(qp.shape[0]):
  if qp[i]!=qy[i]: erros+=1
print("Erros=%d/%d.   Pct=%1.3f%%\n"%(erros,qp.shape[0],100.0*erros/qp.shape[0]))

"""### SVM"""

# classificador Support Vector Machines
machine = svm.SVC()
# Treina o classificador com a base de teste
machine = machine.fit(ax,ay.ravel())
# Realiza a predição na base de teste
qp=machine.predict(qx)
erros=0;
for i in range(qp.shape[0]):
  if qp[i]!=qy[i]: erros+=1
print("Erros=%d/%d.   Pct=%1.3f%%\n"%(erros,qp.shape[0],100.0*erros/qp.shape[0]))